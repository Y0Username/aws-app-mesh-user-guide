<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "file://zonbook/docbookx.dtd"
[
  <!ENTITY % xinclude SYSTEM "file://AWSShared/common/xinclude.mod">
  %xinclude;
  <!ENTITY % phrases-shared SYSTEM "file://AWSShared/common/phrases-shared.ent">
  %phrases-shared;
<!ENTITY % phrases-appmesh SYSTEM "../shared/phrases-app-mesh.ent"> 
    %phrases-appmesh;
]>
<section role="topic" id="getting-started-kubernetes">
    <info>
        <title id="getting-started-kubernetes.title">Getting started with &MESHlong; and
            Kubernetes</title>
        <titleabbrev>&MESH; and Kubernetes</titleabbrev>
    </info>
    <para>When you integrate &MESHlong; with Kubernetes using the &MESH; controller for Kubernetes,
        you manage &MESH; resources, such as meshes, virtual services, virtual nodes, virtual
        routers, and routes through Kubernetes. You also automatically add the &MESH; sidecar
        container images to Kubernetes pod specifications. This tutorial guides you through the
        installation of the &MESH; controller for Kubernetes to enable this integration.</para>
    <para>The controller is accompanied by the deployment of the following Kubernetes custom
        resource definitions: <code>meshes</code>, <code>virtual services</code>, <code>virtual
            nodes</code>, <!-- virtual gateways, gateway routes, -->and <code>virtual
        routers</code>. The controller watches for creation, modification, and deletion of the
        custom resources and makes changes to the corresponding &MESH; <xref linkend="meshes"/>,
            <xref linkend="virtual_services"/>, <xref linkend="virtual_nodes"/>, <xref
            linkend="virtual_gateways"/>, <xref linkend="gateway-routes"/>, <xref
            linkend="virtual_routers"/> (including <xref linkend="routes"/>) resources through the
        &MESH; API. To learn more or contribute to the controller, see the <ulink
            url="https://github.com/aws/aws-app-mesh-controller-for-k8s">GitHub
        project</ulink>.</para>
    <para>The controller also installs a webhook that injects the following containers into
        Kubernetes pods that are labeled with a name that you specify.</para>
    <itemizedlist>
        <listitem>
            <para><emphasis role="bold">&MESH; Envoy proxy</emphasis> &endash;
                &envoy-image-description; </para>
        </listitem>
        <listitem>
            <para><emphasis role="bold">&MESH; proxy route manager </emphasis>&endash; Updates
                    <code>iptables</code> rules in a pod's network namespace that route inbound and
                outbound traffic through Envoy. This container runs as a Kubernetes init container
                inside of the pod.</para>
        </listitem>
    </itemizedlist>
    <section id="mesh-k8s-integration-prerequisites">
        <info>
            <title id="mesh-k8s-integration-prerequisites.title">Prerequisites</title>
        </info>
        <itemizedlist>
            <listitem>
                <para>An existing understanding of &MESH; concepts. For more information, see <xref
                        linkend="what-is-app-mesh"/>.</para>
            </listitem>
            <listitem>
                <para>An existing understanding of Kubernetes concepts. For more information, see
                        <ulink
                        url="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">What
                        is Kubernetes</ulink> in the Kubernetes documentation.</para>
            </listitem>
            <listitem>
                <para>An existing Kubernetes cluster running version 1.14 or later. If you don't
                    have an existing cluster, see <ulink type="documentation"
                        url="eks/latest/userguide/getting-started.html">Getting Started with
                        &EKS;</ulink> in the &guide-eks-user;. If you're running your own Kubernetes
                    cluster on &EC2;, then ensure that Docker is authenticated to the &ECR;
                    repository that the Envoy image is in. For more information, see <ulink
                        type="documentation" url="app-mesh/latest/userguide/envoy.html">Envoy
                        image</ulink>, <ulink type="documentation"
                        url="AmazonECR/latest/userguide/Registries.html#registry_auth">Registry
                        authentication</ulink> in the &guide-ecr-user;, and <ulink
                        url="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/"
                        >Pull an Image from a Private Registry</ulink> in the Kubernetes
                    documentation.</para>
            </listitem>
            <listitem>
                <para>&MESH; supports Linux services that are registered with DNS, &CMAP;, or both.
                    To use this getting started guide, we recommend that you have three existing
                    services that are registered with DNS. The procedures in this topic assume that
                    the existing services are named <code>serviceA</code>, <code>serviceB</code>,
                    and <code>serviceBv2</code> and that all services are discoverable through a
                    namespace named <code>apps.local</code>.</para>
                <para>You can create a service mesh and its resources even if the services
                    don&apos;t exist, but you cannot use the mesh until you have deployed actual
                    services.</para>
            </listitem>
            <listitem>
                <para>The &CLI; version &aws_cli_min_version; or later or &aws_cli_min_version_2; or
                    later installed. To install or upgrade the &CLI;, see <ulink
                        url="&url-cli-ug;cli-chap-install.html">Installing the &CLI;</ulink>.
                </para>
            </listitem>
            <listitem>
                <para>A <code>kubectl</code> client that is configured to communicate with your
                    Kubernetes cluster. If you're using &EKSlong;, you can use the instructions for
                    installing <code><ulink type="documentation"
                            url="eks/latest/userguide/install-kubectl.html">kubectl</ulink></code>
                    and configuring a <code><ulink type="documentation"
                            url="eks/latest/userguide/create-kubeconfig.html"
                        >kubeconfig</ulink></code> file.</para>
            </listitem>
            <listitem>
                <para>Helm version 3.0 or later installed. If you don't have Helm installed, see
                        <ulink type="documentation" url="eks/latest/userguide/helm.html">Using Helm
                        with &EKS;</ulink> in the &guide-eks-user;.</para>
            </listitem>
        </itemizedlist>
        <para>The remaining steps assume that the actual services are named <code>serviceA</code>,
                <code>serviceB</code>, and <code>serviceBv2</code> and that all services are
            discoverable through a namespace named <code>apps.local</code>.</para>
    </section>
    <section id="install-controller">
        <info>
            <title id="install-controller.title">Step 1: Install the integration components</title>
        </info>
        <para>Install the integration components one time to each cluster that hosts pods that you
            want to use with &MESH;.</para>
        <procedure>
            <title>To install the integration components</title>
            <step>
                <para>The remaining steps of this procedure require a cluster without a pre-release
                    version of the controller installed. If you have installed a pre-release
                    version, or are not sure whether you have, you can download and run a script
                    that will check to see whether a pre-release version is installed on your
                    cluster.</para>
                <programlisting>curl -o pre_upgrade_check.sh https://raw.githubusercontent.com/aws/eks-charts/master/stable/appmesh-controller/upgrade/pre_upgrade_check.sh
./pre_upgrade_check.sh</programlisting>
                <para>If the script returns <code>Your cluster is ready for upgrade. Please proceed
                        to the installation instructions</code> then you can proceed to the next
                    step. If a different message is returned, then you'll need to complete the
                    upgrade steps before continuing. For more information about upgrading a
                    pre-release version, see <ulink
                        url="https://github.com/aws/eks-charts/blob/master/stable/appmesh-controller/README.md#upgrade"
                        >Upgrade</ulink> on GitHub.</para>
            </step>
            <step>
                <para>Add the <code>eks-charts</code> repository to Helm.</para>
                <programlisting><userinput>helm repo add eks https://aws.github.io/eks-charts</userinput></programlisting>
            </step>
            <step>
                <para>Install the &MESH; Kubernetes custom resource definitions (CRD).</para>
                <programlisting><userinput>kubectl apply -k "https://github.com/aws/eks-charts/stable/appmesh-controller/crds?ref=master"</userinput></programlisting>
            </step>
            <step>
                <para>Create a Kubernetes namespace for the controller.</para>
                <programlisting><userinput>kubectl create ns appmesh-system</userinput></programlisting>
            </step>
            <step>
                <para>Set the following variables for use in later steps. Replace
                            <code><replaceable>cluster-name</replaceable></code> and
                            <code><replaceable>Region-code</replaceable></code> with the values for
                    your existing cluster.</para>
                <programlisting><userinput>export CLUSTER_NAME=<replaceable>cluster-name</replaceable>
export AWS_REGION=<replaceable>Region-code</replaceable></userinput></programlisting>
            </step>
            <step>
                <para>(Optional) If you want to run the controller on Fargate, then you need to
                    create a Fargate profile. If you don't have <code>eksctl</code> installed, see
                        <ulink type="documentation"
                        url="eks/latest/userguide/eksctl.html#installing-eksctl">Installing or
                        Upgrading <code>eksctl</code></ulink> in the &guide-eks-user;. If you'd
                    prefer to create the profile using the console, see <ulink type="documentation"
                        url="eks/latest/userguide/fargate-profile.html#create-fargate-profile"
                        >Creating a Fargate profile</ulink> in the &guide-eks-user;.</para>
                <programlisting><userinput>eksctl create fargateprofile --cluster $CLUSTER_NAME --name <replaceable>appmesh-system</replaceable> --namespace <replaceable>appmesh-system</replaceable></userinput></programlisting>
            </step>
            <step>
                <para>Create an OpenID Connect (OIDC) identity provider for your cluster. If you
                    don't have <code>eksctl</code> installed, you can install it with the
                    instructions in <ulink type="documentation"
                        url="eks/latest/userguide/eksctl.html#installing-eksctl">Installing or
                        upgrading <code>eksctl</code></ulink> in the &guide-eks-user;. If you'd
                    prefer to create the provider using the console, see <ulink type="documentation"
                        url="eks/latest/userguide/enable-iam-roles-for-service-accounts.html"
                        >Enabling IAM roles for service accounts on your cluster</ulink> in the
                    &guide-eks-user;.</para>
                <programlisting><userinput>eksctl utils associate-iam-oidc-provider \
    --region=$AWS_REGION \
    --cluster $CLUSTER_NAME \
    --approve</userinput></programlisting>
            </step>
            <step>
                <para>Create an IAM role, attach the <ulink type="console"
                        url="iam/home?#policies/arn:aws:iam::aws:policy/AWSAppMeshFullAccess$jsonEditor"
                        >AWSAppMeshFullAccess</ulink> and <ulink type="console"
                        url="iam/home?#policies/arn:aws:iam::aws:policy/AWSCloudMapFullAccess$jsonEditor"
                        >AWSCloudMapFullAccess</ulink> &AWS; managed policies to it, and bind it to
                    the <code>appmesh-controller</code> Kubernetes service account. The role enables
                    the controller to add, remove, and change &MESH; resources.</para>
                <note>
                    <para>The command creates an &AWS; &IAM; role with an auto-generated name. You
                        are not able to specify the &IAM; role name that is created.</para>
                </note>
                <programlisting><userinput>eksctl create iamserviceaccount \
    --cluster $CLUSTER_NAME \
    --namespace appmesh-system \
    --name appmesh-controller \
    --attach-policy-arn  arn:aws:iam::aws:policy/AWSCloudMapFullAccess,arn:aws:iam::aws:policy/AWSAppMeshFullAccess \
    --override-existing-serviceaccounts \
    --approve</userinput></programlisting>
                <para>If you prefer to create the service account using the &console; or &CLI;, see
                        <ulink type="documentation"
                        url="eks/latest/userguide/create-service-account-iam-policy-and-role.html#create-service-account-iam-role"
                        >Creating an &IAM; role and policy for your service account</ulink> in the
                    &guide-eks-user;. If you use the &console; or &CLI; to create the account, you
                    also need to map the role to a Kubernetes service account. For more information,
                    see <ulink type="documentation"
                        url="eks/latest/userguide/specify-service-account-role.html">Specifying an
                        IAM role for your service account</ulink> in the &guide-eks-user;. </para>
            </step>
            <step>
                <para>Deploy the &MESH; controller. For a list of all configuration options, see
                        <ulink
                        url="https://github.com/aws/eks-charts/blob/master/stable/appmesh-controller/README.md#configuration"
                        >Configuration</ulink> on GitHub.</para>
                <programlisting><userinput>helm upgrade -i appmesh-controller eks/appmesh-controller \
    --namespace appmesh-system \
    --set region=$AWS_REGION \
    --set serviceAccount.create=false \
    --set serviceAccount.name=appmesh-controller</userinput></programlisting>
                <important>
                    <para>If your cluster is in the <code>me-south-1</code> or
                            <code>ap-east-1</code> Regions, then you need to add the following
                        option to the previous command:</para>
                    <programlisting>--set sidecar.image.repository=<replaceable>account-id</replaceable>.dkr.ecr.<replaceable>Region-code</replaceable>.amazonaws.com/aws-appmesh-envoy</programlisting>
                    <para>Replace <replaceable>account-id</replaceable> and
                            <replaceable>Region-code</replaceable> with one of the appropriate sets
                        of values.</para>
                    <itemizedlist>
                        <listitem>
                            <para>&envoy-image-me-south-1;</para>
                        </listitem>
                        <listitem>
                            <para>&envoy-image-ap-east-1;</para>
                        </listitem>
                    </itemizedlist>
                    <!-- the
                        value returned from one of the following commands.</para>
                    <programlisting><userinput>aws ssm get-parameter -name "/aws/service/appmesh/envoy" -region me-south-1 -query "Parameter.Value" -output text</userinput></programlisting>
                    <programlisting><userinput>aws ssm get-parameter -name "/aws/service/appmesh/envoy" -region ap-east-1 -query "Parameter.Value" -output text</userinput></programlisting>
                    <para>Output</para>
                    <programlisting role="nocopy"><replaceable>account-id</replaceable>.dkr.ecr.<replaceable>region-code</replaceable>.amazonaws.com/aws-appmesh-envoy:v<replaceable>envoy-image-version</replaceable></programlisting> -->
                </important> &envoy-min-supported-version-note; </step>
            <step>
                <para>Confirm that the controller version is <code>v1.0.0</code> or later. You can
                    review the <ulink
                        url="https://github.com/aws/aws-app-mesh-controller-for-k8s/releases">change
                        log</ulink> on GitHub.</para>
                <programlisting><userinput>kubectl get deployment appmesh-controller \
    -n appmesh-system \
    -o json  | jq -r ".spec.template.spec.containers[].image" | cut -f2 -d ':'</userinput></programlisting>
                <note>
                    <para>If you view the log for the running container, you may see a line that
                        includes the following text, which can be safely ignored.</para>
                    <programlisting role="nocopy">Neither -kubeconfig nor -master was specified. Using the inClusterConfig. This might not work.</programlisting>
                </note>
            </step>
        </procedure>
    </section>
    <section id="configure-app-mesh">
        <info>
            <title id="configure-app-mesh.title">Step 2: Deploy &MESH; resources</title>
        </info>
        <para>When you deploy an application in Kubernetes, you also create the Kubernetes custom
            resources so that the controller can create the corresponding &MESH; resources. The
            following procedure helps you deploy &MESH; resources with some of their features. You
            can find example manifests for deploying other &MESH; resource features in the
                <code>v1beta2</code> sub-folders of many of the feature folders listed at <ulink
                url="https://github.com/aws/aws-app-mesh-examples/tree/master/walkthroughs">&MESH;
                walkthroughs</ulink> on GitHub.</para>
        <important>
            <para>Once the controller has created an &MESH; resource, we recommend that you only
                make changes to, or delete the &MESH; resource, using the controller. If you make
                changes to or delete the resource using &MESH;, the controller won't change or
                recreate the changed or deleted &MESH; resource for ten hours, by default. You can
                configure this duration to be less. For more information, see <ulink
                    url="https://github.com/aws/eks-charts/blob/master/stable/appmesh-controller/README.md#configuration"
                    >Configuration</ulink> on GitHub.</para>
        </important>
        <procedure>
            <title>To deploy App Mesh resources</title>
            <step>
                <para>Create a Kubernetes namespace to deploy &MESH; resources to. </para>
                <substeps>
                    <step>
                        <para>Save the following contents to a file named
                                <code>namespace.yaml</code> on your computer.</para>
                        <programlisting language="yaml">apiVersion: v1
kind: Namespace
metadata:
  name: <replaceable>my-apps
</replaceable>  labels:
    mesh: <replaceable>my-mesh</replaceable>
    appmesh.k8s.aws/sidecarInjectorWebhook: enabled</programlisting>
                    </step>
                    <step>
                        <para>Create the namespace.</para>
                        <programlisting><userinput>kubectl apply -f namespace.yaml</userinput></programlisting>
                    </step>
                </substeps>
            </step>
            <step>
                <para>Create an &MESH; service mesh.</para>
                <substeps>
                    <step>
                        <para>Save the following contents to a file named <code>mesh.yaml</code> on
                            your computer. The file will be used to create a mesh resource named
                                    <code><replaceable>my-mesh</replaceable></code>. A service mesh
                            is a logical boundary for network traffic between the services that
                            reside within it.</para>
                        <programlisting language="yaml">apiVersion: appmesh.k8s.aws/v1beta2
kind: Mesh
metadata:
  name: <replaceable>my-mesh</replaceable>
spec:
  namespaceSelector:
    matchLabels:
      mesh: <replaceable>my-mesh</replaceable></programlisting>
                    </step>
                    <step>
                        <para>Create the mesh.</para>
                        <programlisting><userinput>kubectl apply -f mesh.yaml</userinput></programlisting>
                    </step>
                    <step>
                        <para>View the details of the Kubernetes mesh resource that was
                            created.</para>
                        <programlisting><userinput>kubectl describe mesh <replaceable>my-mesh</replaceable></userinput></programlisting>
                        <para>Output</para>
                        <programlisting role="nocopy">Name:         my-mesh
Namespace:
Labels:       &lt;none>
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {"apiVersion":"appmesh.k8s.aws/v1beta2","kind":"Mesh","metadata":{"annotations":{},"name":"my-mesh"},"spec":{"namespaceSelector":{"matchLa...
API Version:  appmesh.k8s.aws/v1beta2
Kind:         Mesh
Metadata:
  Creation Timestamp:  2020-06-17T14:51:37Z
  Finalizers:
    finalizers.appmesh.k8s.aws/mesh-members
    finalizers.appmesh.k8s.aws/aws-appmesh-resources
  Generation:        1
  Resource Version:  6295
  Self Link:         /apis/appmesh.k8s.aws/v1beta2/meshes/my-mesh
  UID:               &mesh-example-uid;
Spec:
  Aws Name:  my-mesh
  Namespace Selector:
    Match Labels:
      Mesh:  my-mesh
Status:
  Conditions:
    Last Transition Time:  2020-06-17T14:51:37Z
    Status:                True
    Type:                  MeshActive
  Mesh ARN:                arn:aws:appmesh:us-west-2:&ExampleAWSAccountNo1;:mesh/my-mesh
  Observed Generation:     1
Events:                    &lt;none></programlisting>
                    </step>
                    <step>
                        <para>View the details about the &MESH; service mesh that the controller
                            created.</para>
                        <programlisting><userinput>aws appmesh describe-mesh --mesh-name <replaceable>my-mesh</replaceable></userinput></programlisting>
                        <para>Output</para>
                        <programlisting role="nocopy" language="json">{
    "mesh": {
        "meshName": "my-mesh",
        "metadata": {
            "arn": "arn:aws:appmesh:us-west-2:&ExampleAWSAccountNo1;:mesh/my-mesh",
            "createdAt": "2020-06-17T09:51:37.920000-05:00",
            "lastUpdatedAt": "2020-06-17T09:51:37.920000-05:00",
            "meshOwner": "&ExampleAWSAccountNo1;",
            "resourceOwner": "&ExampleAWSAccountNo1;",
            "uid": "&mesh-example-uid;",
            "version": 1
        },
        "spec": {},
        "status": {
            "status": "ACTIVE"
        }
    }
}</programlisting>
                    </step>
                </substeps>
            </step>
            <step>
                <para>Create an &MESH; virtual node. A virtual node acts as a logical pointer to a
                    Kubernetes deployment.</para>
                <substeps>
                    <step>
                        <para>Save the following contents to a file named
                                <code>virtual-node.yaml</code> on your computer. The file will be
                            used to create an &MESH; virtual node named
                                    <code><replaceable>my-service-a</replaceable></code> in the
                                    <replaceable><code>my-apps</code></replaceable> namespace. The
                            virtual node represents a Kubernetes service that is created in a later
                            step. The value for <code>hostname</code> is the fully qualified DNS
                            hostname of the actual service that this virtual node represents.</para>
                        <programlisting language="yaml">apiVersion: appmesh.k8s.aws/v1beta2
kind: VirtualNode
metadata:
  name: <replaceable>my-service-a</replaceable>
  namespace: <replaceable>my-apps</replaceable>
spec:
  podSelector:
    matchLabels:
      app: <replaceable>my-app-1</replaceable>
  listeners:
    - portMapping:
        port: <replaceable>80</replaceable>
        protocol: <replaceable>http</replaceable>
  serviceDiscovery:
    dns:
      hostname: <replaceable>my-service-a.my-apps.svc.cluster.local</replaceable></programlisting>
                        <para>Virtual nodes have capabilities, such as end-to-end encryption and
                            health checks, that aren't covered in this tutorial. For more
                            information, see <xref linkend="virtual_nodes"/>. To see all available
                            settings for a virtual node that you can set in the preceding spec, run
                            the following command.</para>
                        <programlisting><userinput>aws appmesh create-virtual-node --generate-cli-skeleton yaml-input</userinput></programlisting>
                    </step>
                    <step>
                        <para>Deploy the virtual node.</para>
                        <programlisting><userinput>kubectl apply -f virtual-node.yaml</userinput></programlisting>
                    </step>
                    <step>
                        <para>View the details of the Kubernetes virtual node resource that was
                            created.</para>
                        <programlisting><userinput>kubectl describe virtualnode <replaceable>my-service-a</replaceable> -n <replaceable>my-apps</replaceable></userinput></programlisting>
                        <para>Output</para>
                        <programlisting role="nocopy">Name:         my-service-a
Namespace:    my-apps
Labels:       &lt;none>
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {"apiVersion":"appmesh.k8s.aws/v1beta2","kind":"VirtualNode","metadata":{"annotations":{},"name":"my-service-a","namespace":"my-apps"},"s...
API Version:  appmesh.k8s.aws/v1beta2
Kind:         VirtualNode
Metadata:
  Creation Timestamp:  2020-06-17T14:57:29Z
  Finalizers:
    finalizers.appmesh.k8s.aws/aws-appmesh-resources
  Generation:        2
  Resource Version:  22545
  Self Link:         /apis/appmesh.k8s.aws/v1beta2/namespaces/my-apps/virtualnodes/my-service-a
  UID:               &mesh-example-uid;
Spec:
  Aws Name:  my-service-a_my-apps
  Listeners:
    Port Mapping:
      Port:      80
      Protocol:  http
  Mesh Ref:
    Name:  my-mesh
    UID:   &mesh-example-uid;
  Pod Selector:
    Match Labels:
      App:  nginx
  Service Discovery:
    Dns:
      Hostname:  my-service-a.my-apps.svc.cluster.local
Status:
  Conditions:
    Last Transition Time:  2020-06-17T14:57:29Z
    Status:                True
    Type:                  VirtualNodeActive
  Observed Generation:     2
  Virtual Node ARN:        arn:aws:appmesh:us-west-2:&ExampleAWSAccountNo1;:mesh/my-mesh/virtualNode/my-service-a_my-apps
Events:                    &lt;none></programlisting>
                    </step>
                    <step>
                        <para>View the details of the virtual node that the controller created in
                            &MESH;.</para>
                        <note>
                            <para>Even though the name of the virtual node created in Kubernetes is
                                        <code><replaceable>my-service-a</replaceable></code>, the
                                name of the virtual node created in App Mesh is
                                        <code><replaceable>my-service-a_my-apps</replaceable></code>.
                                The controller appends the Kubernetes namespace name to the &MESH;
                                virtual node name when it creates the &MESH; resource. The namespace
                                name is added because in Kubernetes you can create virtual nodes
                                with the same name in different namespaces, but in &MESH; a virtual
                                node name must be unique within a mesh.</para>
                        </note>
                        <programlisting><userinput>aws appmesh describe-virtual-node --mesh-name <replaceable>my-mesh</replaceable> --virtual-node-name <replaceable>my-service-a_my-apps</replaceable></userinput></programlisting>
                        <para>Output</para>
                        <programlisting role="nocopy" language="json">{
    "virtualNode": {
        "meshName": "my-mesh",
        "metadata": {
            "arn": "arn:aws:appmesh:us-west-2:&ExampleAWSAccountNo1;:mesh/my-mesh/virtualNode/my-service-a_my-apps",
            "createdAt": "2020-06-17T09:57:29.840000-05:00",
            "lastUpdatedAt": "2020-06-17T09:57:29.840000-05:00",
            "meshOwner": "&ExampleAWSAccountNo1;",
            "resourceOwner": "&ExampleAWSAccountNo1;",
            "uid": "&mesh-example-uid;",
            "version": 1
        },
        "spec": {
            "backends": [],
            "listeners": [
                {
                    "portMapping": {
                        "port": 80,
                        "protocol": "http"
                    }
                }
            ],
            "serviceDiscovery": {
                "dns": {
                    "hostname": "my-service-a.my-apps.svc.cluster.local"
                }
            }
        },
        "status": {
            "status": "ACTIVE"
        },
        "virtualNodeName": "my-service-a_my-apps"
    }
}</programlisting>
                    </step>
                </substeps>
            </step>
            <step>
                <para>Create an &MESH; virtual router. Virtual routers handle traffic for one or
                    more virtual services within your mesh.</para>
                <substeps>
                    <step>
                        <para>Save the following contents to a file named
                                <code>virtual-router.yaml</code> on your computer. The file will be
                            used to create a virtual router to route traffic to the virtual node
                            named <code>my-service-a</code> that was created in the previous step.
                            The controller will create the &MESH; virtual router and route
                            resources. You can specify many more capabilities for your routes and
                            use protocols other than <code>http</code>. For more information, see
                                <xref linkend="virtual_routers"/> and <xref linkend="routes"/>.
                            Notice that the virtual node name referenced is the Kubernetes virtual
                            node name, not the &MESH; virtual node name that was created in &MESH;
                            by the controller.</para>
                        <programlisting language="yaml">apiVersion: appmesh.k8s.aws/v1beta2
kind: VirtualRouter
metadata:
  namespace: <replaceable>my-apps</replaceable>
  name: <replaceable>my-service-a-virtual-router</replaceable>
spec:
  listeners:
    - portMapping:
        port: <replaceable>80
</replaceable>        protocol: <replaceable>http</replaceable>
  routes:
    - name: <replaceable>my-service-a-route</replaceable>
      httpRoute:
        match:
          prefix: <replaceable>/</replaceable>
        action:
          weightedTargets:
            - virtualNodeRef:
                name: <replaceable>my-service-a</replaceable>
              weight: <replaceable>1</replaceable></programlisting>
                        <para>(Optional) To see all available settings for a virtual router that you
                            can set in the preceding spec, run any of the following command.</para>
                        <programlisting><userinput>aws appmesh create-virtual-router --generate-cli-skeleton yaml-input</userinput></programlisting>
                        <para>To see all available settings for a route that you can set in the
                            preceding spec, run any of the following command.</para>
                        <programlisting><userinput>aws appmesh create-route --generate-cli-skeleton yaml-input</userinput></programlisting>
                    </step>
                    <step>
                        <para>Deploy the virtual router.</para>
                        <programlisting><userinput>kubectl apply -f virtual-router.yaml</userinput></programlisting>
                    </step>
                    <step>
                        <para>View the Kubernetes virtual router resource that was created.</para>
                        <programlisting><userinput>kubectl describe virtualrouter <replaceable>my-service-a-virtual-router</replaceable> -n <replaceable>my-apps</replaceable></userinput></programlisting>
                        <para>Abbreviated output</para>
                        <programlisting>Name:         my-service-a-virtual-router
Namespace:    my-apps
Labels:       &lt;none>
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {"apiVersion":"appmesh.k8s.aws/v1beta2","kind":"VirtualRouter","metadata":{"annotations":{},"name":"my-service-a-virtual-router","namespac...
API Version:  appmesh.k8s.aws/v1beta2
Kind:         VirtualRouter
...
Spec:
  Aws Name:  my-service-a-virtual-router_my-apps
  Listeners:
    Port Mapping:
      Port:      80
      Protocol:  http
  Mesh Ref:
    Name:  my-mesh
    UID:   &mesh-example-uid;
  Routes:
    Http Route:
      Action:
        Weighted Targets:
          Virtual Node Ref:
            Name:  my-service-a
          Weight:  1
      Match:
        Prefix:  /
    Name:        my-service-a-route
Status:
  Conditions:
    Last Transition Time:  2020-06-17T15:14:01Z
    Status:                True
    Type:                  VirtualRouterActive
  Observed Generation:     1
  Route AR Ns:
    My - Service - A - Route:  arn:aws:appmesh:us-west-2:&ExampleAWSAccountNo1;:mesh/my-mesh/virtualRouter/my-service-a-virtual-router_my-apps/route/my-service-a-route
  Virtual Router ARN:          arn:aws:appmesh:us-west-2:&ExampleAWSAccountNo1;:mesh/my-mesh/virtualRouter/my-service-a-virtual-router_my-apps
Events:                        &lt;none></programlisting>
                    </step>
                    <step>
                        <para>View the virtual router resource that the controller created in
                            &MESH;. You specify <code>my-service-a-virtual-router_my-apps</code>
                            for <code>name</code>, because when the controller created the virtual
                            router in &MESH;, it appended the Kubernetes namespace name to the name
                            of the virtual router.</para>
                        <programlisting><userinput>aws appmesh describe-virtual-router --virtual-router-name <replaceable>my-service-a-virtual-router_my-apps</replaceable> --mesh-name <replaceable>my-mesh</replaceable></userinput></programlisting>
                        <para>Output</para>
                        <programlisting>{
    "virtualRouter": {
        "meshName": "my-mesh",
        "metadata": {
            "arn": "arn:aws:appmesh:us-west-2:&ExampleAWSAccountNo1;:mesh/my-mesh/virtualRouter/my-service-a-virtual-router_my-apps",
            "createdAt": "2020-06-17T10:14:01.547000-05:00",
            "lastUpdatedAt": "2020-06-17T10:14:01.547000-05:00",
            "meshOwner": "&ExampleAWSAccountNo1;",
            "resourceOwner": "&ExampleAWSAccountNo1;",
            "uid": "&mesh-example-uid;",
            "version": 1
        },
        "spec": {
            "listeners": [
                {
                    "portMapping": {
                        "port": 80,
                        "protocol": "http"
                    }
                }
            ]
        },
        "status": {
            "status": "ACTIVE"
        },
        "virtualRouterName": "my-service-a-virtual-router_my-apps"
    }
}</programlisting>
                    </step>
                    <step>
                        <para>View the route resource that the controller created in &MESH;. A route
                            resource was not created in Kubernetes because the route is part of the
                            virtual router configuration in Kubernetes. The route information was
                            shown in the Kubernetes resource detail in sub-step <code>c</code>. The
                            controller did not append the Kubernetes namespace name to the &MESH;
                            route name when it created the route in &MESH; because route names are
                            unique to a virtual router.</para>
                        <programlisting><userinput>aws appmesh <replaceable>describe-route</replaceable> \
    --route-name <replaceable>my-service-a-route</replaceable> \
    --virtual-router-name <replaceable>my-service-a-virtual-router_my-apps</replaceable> \
    --mesh-name <replaceable>my-mesh</replaceable></userinput></programlisting>
                        <para>Output</para>
                        <programlisting>{
    "route": {
        "meshName": "my-mesh",
        "metadata": {
            "arn": "arn:aws:appmesh:us-west-2:&ExampleAWSAccountNo1;:mesh/my-mesh/virtualRouter/my-service-a-virtual-router_my-apps/route/my-service-a-route",
            "createdAt": "2020-06-17T10:14:01.577000-05:00",
            "lastUpdatedAt": "2020-06-17T10:14:01.577000-05:00",
            "meshOwner": "&ExampleAWSAccountNo1;",
            "resourceOwner": "&ExampleAWSAccountNo1;",
            "uid": "&mesh-example-uid;",
            "version": 1
        },
        "routeName": "my-service-a-route",
        "spec": {
            "httpRoute": {
                "action": {
                    "weightedTargets": [
                        {
                            "virtualNode": "my-service-a_my-apps",
                            "weight": 1
                        }
                    ]
                },
                "match": {
                    "prefix": "/"
                }
            }
        },
        "status": {
            "status": "ACTIVE"
        },
        "virtualRouterName": "my-service-a-virtual-router_my-apps"
    }
}</programlisting>
                    </step>
                </substeps>
            </step>
            <step>
                <para>Create an &MESH; virtual service. A virtual service is an abstraction of a
                    real service that is provided by a virtual node directly or indirectly by means
                    of a virtual router. Dependent services call your virtual service by its name.
                    Though the name doesn't matter to &MESH;, we recommend naming the virtual
                    service the fully qualified domain name of the actual service that the virtual
                    service represents. By naming your virtual services this way, you don't need to
                    change your application code to reference a different name. The requests are
                    routed to the virtual node or virtual router that is specified as the provider
                    for the virtual service.</para>
                <substeps>
                    <step>
                        <para>Save the following contents to a file named
                                <code>virtual-service.yaml</code> on your computer. The file will be
                            used to create a virtual service that uses a virtual router provider to
                            route traffic to the virtual node named <code>my-service-a</code> that
                            was created in a previous step. The value for <code>awsName</code> in
                            the <code>spec</code> is the fully qualified domain name (FQDN) of the
                            actual Kubernetes service that this virtual service abstracts. The
                            Kubernetes service is created in <xref linkend="create-update-services"
                            />. For more information, see <xref linkend="virtual_services"/>.</para>
                        <programlisting>apiVersion: appmesh.k8s.aws/v1beta2
kind: VirtualService
metadata:
  name: <replaceable>my-service-a</replaceable>
  namespace: <replaceable>my-apps</replaceable>
spec:
  awsName: <replaceable>my-service-a.my-apps.svc.cluster.local</replaceable>
  provider:
    virtualRouter:
      virtualRouterRef:
        name: <replaceable>my-service-a-virtual-router</replaceable></programlisting>
                        <para>To see all available settings for a virtual service that you can set
                            in the preceding spec, run the following command.</para>
                        <programlisting><userinput>aws appmesh create-virtual-service --generate-cli-skeleton yaml-input</userinput></programlisting>
                    </step>
                    <step>
                        <para>Create the virtual service.</para>
                        <programlisting><userinput>kubectl apply -f virtual-service.yaml</userinput></programlisting>
                    </step>
                    <step>
                        <para>View the details of the Kubernetes virtual service resource that was
                            created.</para>
                        <programlisting><userinput>kubectl describe virtualservice <replaceable>my-service-a</replaceable> -n <replaceable>my-apps</replaceable></userinput></programlisting>
                        <para>Output</para>
                        <programlisting>Name:         my-service-a
Namespace:    my-apps
Labels:       &lt;none>
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {"apiVersion":"appmesh.k8s.aws/v1beta2","kind":"VirtualService","metadata":{"annotations":{},"name":"my-service-a","namespace":"my-apps"}...
API Version:  appmesh.k8s.aws/v1beta2
Kind:         VirtualService
Metadata:
  Creation Timestamp:  2020-06-17T15:48:40Z
  Finalizers:
    finalizers.appmesh.k8s.aws/aws-appmesh-resources
  Generation:        1
  Resource Version:  13598
  Self Link:         /apis/appmesh.k8s.aws/v1beta2/namespaces/my-apps/virtualservices/my-service-a
  UID:               &mesh-example-uid;
Spec:
  Aws Name:  my-service-a.my-apps.svc.cluster.local
  Mesh Ref:
    Name:  my-mesh
    UID:   &mesh-example-uid;
  Provider:
    Virtual Router:
      Virtual Router Ref:
        Name:  my-service-a-virtual-router
Status:
  Conditions:
    Last Transition Time:  2020-06-17T15:48:40Z
    Status:                True
    Type:                  VirtualServiceActive
  Observed Generation:     1
  Virtual Service ARN:     arn:aws:appmesh:us-west-2:&ExampleAWSAccountNo1;:mesh/my-mesh/virtualService/my-service-a.my-apps.svc.cluster.local
Events:                    &lt;none></programlisting>
                    </step>
                    <step>
                        <para>View the details of the virtual service resource that the controller
                            created in &MESH;. The Kubernetes controller did not append the
                            Kubernetes namespace name to the &MESH; virtual service name when it
                            created the virtual service in &MESH; because the virtual service's name
                            is a unique FQDN.</para>
                        <programlisting><userinput>aws appmesh describe-virtual-service --virtual-service-name <replaceable>my-service-a.my-apps.svc.cluster.local</replaceable> --mesh-name <replaceable>my-mesh</replaceable></userinput></programlisting>
                        <para>Output</para>
                        <programlisting role="nocopy">{
    "virtualService": {
        "meshName": "my-mesh",
        "metadata": {
            "arn": "arn:aws:appmesh:us-west-2:&ExampleAWSAccountNo1;:mesh/my-mesh/virtualService/my-service-a.my-apps.svc.cluster.local",
            "createdAt": "2020-06-17T10:48:40.182000-05:00",
            "lastUpdatedAt": "2020-06-17T10:48:40.182000-05:00",
            "meshOwner": "&ExampleAWSAccountNo1;",
            "resourceOwner": "&ExampleAWSAccountNo1;",
            "uid": "&mesh-example-uid;",
            "version": 1
        },
        "spec": {
            "provider": {
                "virtualRouter": {
                    "virtualRouterName": "my-service-a-virtual-router_my-apps"
                }
            }
        },
        "status": {
            "status": "ACTIVE"
        },
        "virtualServiceName": "my-service-a.my-apps.svc.cluster.local"
    }
}</programlisting>
                    </step>
                </substeps>
            </step>
        </procedure>
        <para>Though not covered in this tutorial, the controller can also deploy &MESH; <xref
                linkend="virtual_gateways"/> and <xref linkend="gateway-routes"/>. For a walkthrough
            of deploying these resources with the controller, see <ulink
                url="https://github.com/aws/aws-app-mesh-examples/tree/master/walkthroughs/howto-k8s-ingress-gateway"
                >Configuring Inbound Gateway</ulink>, or a <ulink
                url="https://github.com/aws/aws-app-mesh-examples/blob/master/walkthroughs/howto-k8s-ingress-gateway/v1beta2/manifest.yaml.template"
                >sample manifest</ulink> that includes the resources on GitHub.</para>
    </section>
    <section id="create-update-services">
        <info>
            <title id="create-update-services.title">Step 3: Create or update services</title>
        </info>
        <para>Any pods that you want to use with &MESH; must have the &MESH; sidecar containers
            added to them. The injector automatically adds the sidecar containers to any pod
            deployed with a label that you specify.</para>
        <procedure>
            <step>
                <para>Enable proxy authorization. We recommend that you enable each Kubernetes
                    deployment to stream only the configuration for its own &MESH; virtual
                    node.</para>
                <substeps>
                    <step>
                        <para>Save the following contents to a file named
                                <code>proxy-auth.json</code> on your computer. Make sure to replace
                            the <replaceable>alternate-colored values</replaceable> with your
                            own.</para>
                        <programlisting language="json">{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "appmesh:StreamAggregatedResources",
            "Resource": [
                "arn:aws:appmesh:<replaceable>Region-code</replaceable>:<replaceable>&ExampleAWSAccountNo1;</replaceable>:mesh/my-mesh/virtualNode/my-service-a_my-apps"
            ]
        }
    ]
}</programlisting>
                    </step>
                    <step>
                        <para>Create the policy.</para>
                        <programlisting><userinput>aws iam create-policy --policy-name <replaceable>my-policy</replaceable> --policy-document file://proxy-auth.json</userinput></programlisting>
                    </step>
                    <step>
                        <para>Create an IAM role, attach the policy you created in the previous step
                            to it, create a Kubernetes service account and bind the policy to the
                            Kubernetes service account. The role enables the controller to add,
                            remove, and change App Mesh resources.</para>
                        <programlisting><userinput>eksctl create iamserviceaccount \
    --cluster $CLUSTER_NAME \
    --namespace <replaceable>my-apps</replaceable> \
    --name <replaceable>my-service-a</replaceable> \
    --attach-policy-arn  arn:aws:iam::<replaceable>111122223333</replaceable>:policy/<replaceable>my-policy</replaceable> \
    --override-existing-serviceaccounts \
    --approve</userinput></programlisting>
                        <para>If you prefer to create the service account using the &console; or
                            &CLI;, see <ulink type="documentation"
                                url="eks/latest/userguide/create-service-account-iam-policy-and-role.html#create-service-account-iam-role"
                                >Creating an IAM Role and policy for your service account</ulink> in
                            the &guide-eks-user;. If you use the &console; or &CLI; to create the
                            account, you also need to map the role to a Kubernetes service account.
                            For more information, see <ulink type="documentation"
                                url="eks/latest/userguide/specify-service-account-role.html"
                                >Specifying an &IAM; role for your service account</ulink> in the
                            &guide-eks-user;.</para>
                    </step>
                </substeps>
            </step>
            <step>
                <para>(Optional) If you want to deploy your deployment to Fargate pods, then you
                    need to create a Fargate profile. If you don't have <code>eksctl</code>
                    installed, you can install it with the instructions in <ulink
                        type="documentation"
                        url="eks/latest/userguide/eksctl.html#installing-eksctl">Installing or
                        Upgrading <code>eksctl</code></ulink> in the &guide-eks-user;. If you'd
                    prefer to create the profile using the console, see <ulink type="documentation"
                        url="eks/latest/userguide/fargate-profile.html#create-fargate-profile"
                        >Creating a Fargate profile</ulink> in the &guide-eks-user;.</para>
                <programlisting><userinput>eksctl create fargateprofile --cluster <replaceable>my-cluster</replaceable> --region <replaceable>Region-code</replaceable> --name <replaceable>my-service-a</replaceable> --namespace <replaceable>my-apps</replaceable></userinput></programlisting>
            </step>
            <step>
                <para>Create a Kubernetes service and deployment. If you have an existing deployment
                    that you want to use with &MESH;, then you need to deploy a virtual node, as you
                    did in sub-step <code>3</code> of <xref linkend="configure-app-mesh"/>, and
                    update your deployment to make sure that its label matches the label that you
                    set on the virtual node, so that the sidecar containers are automatically added
                    to the pods and the pods are redeployed.</para>
                <substeps>
                    <step>
                        <para>Save the following contents to a file named
                                <code>example-service.yaml</code> on your computer. If you change
                            the namespace name and are using Fargate pods, make sure that the
                            namespace name matches the namespace name that you defined in your
                            Fargate profile.</para>
                        <programlisting language="yaml">apiVersion: v1
kind: Service
metadata:
  name: <replaceable>my-service-a</replaceable>
  namespace: <replaceable>my-apps</replaceable>
  labels:
    app: <replaceable>my-app-1</replaceable>
spec:
  selector:
    app: <replaceable>my-app-1</replaceable>
  ports:
    - protocol: <replaceable>TCP</replaceable>
      port: <replaceable>80</replaceable>
      targetPort: <replaceable>80</replaceable>
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: <replaceable>my-service-a</replaceable>
  namespace: <replaceable>my-apps</replaceable>
  labels:
    app: <replaceable>my-app-1</replaceable>
spec:
  replicas: <replaceable>3</replaceable>
  selector:
    matchLabels:
      app: <replaceable>my-app-1</replaceable>
  template:
    metadata:
      labels:
        app: <replaceable>my-app-1</replaceable>
    spec:
      serviceAccountName: <replaceable>my-service-a</replaceable>
      containers:
      - name: <replaceable>nginx</replaceable>
        image: <replaceable>nginx:1.19.0</replaceable>
        ports:
        - containerPort: <replaceable>80</replaceable></programlisting>
                        <important>
                            <para>The value for the <code>app</code>
                                <code>matchLabels</code>
                                <code>selector</code> in the spec must match the value that you
                                specified when you created the virtual node in sub-step
                                    <code>3</code> of <xref linkend="configure-app-mesh"/>, or the
                                sidecar containers won't be injected into the pod. In the previous
                                example, the value for the label is <code>my-app-1</code>. If you
                                deploy a virtual gateway, rather than a virtual node, then the
                                    <code>Deployment</code> manifest should include only the Envoy
                                container. For more information about the image to use, see <xref
                                    linkend="envoy"/>. For a sample manfest, see the <ulink
                                    url="https://github.com/aws/aws-app-mesh-examples/blob/master/walkthroughs/howto-k8s-ingress-gateway/v1beta2/manifest.yaml.template#L585"
                                    >deployment example</ulink> on GitHub.</para>
                        </important>
                    </step>
                    <step>
                        <para>Deploy the service.</para>
                        <programlisting><userinput>kubectl apply -f <replaceable>example-service.yaml</replaceable></userinput></programlisting>
                    </step>
                    <step>
                        <para>View the service and deployment.</para>
                        <programlisting><userinput>kubectl -n <replaceable>my-apps</replaceable> get pods</userinput></programlisting>
                        <para>Output</para>
                        <programlisting role="nocopy">NAME                            READY   STATUS    RESTARTS   AGE
my-service-a-54776556f6-2cxd9   2/2     Running   0          10s
my-service-a-54776556f6-w26kf   2/2     Running   0          18s
my-service-a-54776556f6-zw5kt   2/2     Running   0          26s</programlisting>
                    </step>
                    <step>
                        <para>View the details for one of the pods that was deployed.</para>
                        <programlisting><userinput>kubectl -n <replaceable>my-apps</replaceable> describe pod <replaceable>my-service-a-54776556f6-2cxd9</replaceable></userinput></programlisting>
                        <para>Abbreviated output</para>
                        <programlisting role="nocopy">Name:         my-service-a-54776556f6-2cxd9
Namespace:    my-app-1
Priority:     0
Node:         ip-192-168-44-157.us-west-2.compute.internal/192.168.44.157
Start Time:   Wed, 17 Jun 2020 11:08:59 -0500
Labels:       app=nginx
              pod-template-hash=54776556f6
Annotations:  kubernetes.io/psp: eks.privileged
Status:       Running
IP:           192.168.57.134
IPs:
  IP:           192.168.57.134
Controlled By:  ReplicaSet/my-service-a-54776556f6
Init Containers:
  proxyinit:
    Container ID:   docker://e0c4810d584c21ae0cb6e40f6119d2508f029094d0e01c9411c6cf2a32d77a59
    Image:          111345817488.dkr.ecr.us-west-2.amazonaws.com/aws-appmesh-proxy-route-manager:v2
    Image ID:       docker-pullable://111345817488.dkr.ecr.us-west-2.amazonaws.com/aws-appmesh-proxy-route-manager
    Port:           &lt;none>
    Host Port:      &lt;none>
    State:          Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Fri, 26 Jun 2020 08:36:22 -0500
      Finished:     Fri, 26 Jun 2020 08:36:22 -0500
    Ready:          True
    Restart Count:  0
    Requests:
      cpu:     10m
      memory:  32Mi
    Environment:
      APPMESH_START_ENABLED:         1
      APPMESH_IGNORE_UID:            1337
      APPMESH_ENVOY_INGRESS_PORT:    15000
      APPMESH_ENVOY_EGRESS_PORT:     15001
      APPMESH_APP_PORTS:             80
      APPMESH_EGRESS_IGNORED_IP:     169.254.169.254
      APPMESH_EGRESS_IGNORED_PORTS:  22
      AWS_ROLE_ARN:                  arn:aws:iam::&ExampleAWSAccountNo1;:role/eksctl-app-mesh-addon-iamserviceaccount-my-a-Role1-NMNCVWB6PL0N
      AWS_WEB_IDENTITY_TOKEN_FILE:   /var/run/secrets/eks.amazonaws.com/serviceaccount/token
    ...
Containers:
  nginx:
    Container ID:   docker://be6359dc6ecd3f18a1c87df7b57c2093e1f9db17d5b3a77f22585ce3bcab137a
    Image:          nginx:1.19.0
    Image ID:       docker-pullable://nginx
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Fri, 26 Jun 2020 08:36:28 -0500
    Ready:          True
    Restart Count:  0
    Environment:
      AWS_ROLE_ARN:                 arn:aws:iam::&ExampleAWSAccountNo1;:role/eksctl-app-mesh-addon-iamserviceaccount-my-a-Role1-NMNCVWB6PL0N
      AWS_WEB_IDENTITY_TOKEN_FILE:  /var/run/secrets/eks.amazonaws.com/serviceaccount/token
    ...
  envoy:
    Container ID:   docker://905b55cbf33ef3b3debc51cb448401d24e2e7c2dbfc6a9754a2c49dd55a216b6
    Image:          840364872350.dkr.ecr.us-west-2.amazonaws.com/aws-appmesh-envoy:v1.12.4.0-prod
    Image ID:       docker-pullable://840364872350.dkr.ecr.us-west-2.amazonaws.com/aws-appmesh-envoy
    Port:           9901/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Fri, 26 Jun 2020 08:36:36 -0500
    Ready:          True
    Restart Count:  0
    Requests:
      cpu:     10m
      memory:  32Mi
    Environment:
      APPMESH_RESOURCE_ARN:         arn:aws:iam::&ExampleAWSAccountNo1;:mesh/my-mesh/virtualNode/my-service-a_my-apps
      APPMESH_PREVIEW:              0
      ENVOY_LOG_LEVEL:              info
      AWS_REGION:                   us-west-2
      AWS_ROLE_ARN:                 arn:aws:iam::&ExampleAWSAccountNo1;:role/eksctl-app-mesh-addon-iamserviceaccount-my-a-Role1-NMNCVWB6PL0N
      AWS_WEB_IDENTITY_TOKEN_FILE:  /var/run/secrets/eks.amazonaws.com/serviceaccount/token
...
Events:
  Type    Reason     Age   From                                                   Message
  ----    ------     ----  ----                                                   -------
  Normal  Pulling    30s   kubelet, ip-192-168-44-157.us-west-2.compute.internal  Pulling image "111345817488.dkr.ecr.us-west-2.amazonaws.com/aws-appmesh-proxy-route-manager:v2"
  Normal  Pulled     23s   kubelet, ip-192-168-44-157.us-west-2.compute.internal  Successfully pulled image "111345817488.dkr.ecr.us-west-2.amazonaws.com/aws-appmesh-proxy-route-manager:v2"
  Normal  Created    21s   kubelet, ip-192-168-44-157.us-west-2.compute.internal  Created container proxyinit
  Normal  Started    21s   kubelet, ip-192-168-44-157.us-west-2.compute.internal  Started container proxyinit
  Normal  Pulling    20s   kubelet, ip-192-168-44-157.us-west-2.compute.internal  Pulling image "nginx:1.19.0"
  Normal  Pulled     16s   kubelet, ip-192-168-44-157.us-west-2.compute.internal  Successfully pulled image "nginx:1.19.0"
  Normal  Created    15s   kubelet, ip-192-168-44-157.us-west-2.compute.internal  Created container nginx
  Normal  Started    15s   kubelet, ip-192-168-44-157.us-west-2.compute.internal  Started container nginx
  Normal  Pulling    15s   kubelet, ip-192-168-44-157.us-west-2.compute.internal  Pulling image "840364872350.dkr.ecr.us-west-2.amazonaws.com/aws-appmesh-envoy:v1.12.4.0-prod"
  Normal  Pulled     8s    kubelet, ip-192-168-44-157.us-west-2.compute.internal  Successfully pulled image "840364872350.dkr.ecr.us-west-2.amazonaws.com/aws-appmesh-envoy:v1.12.4.0-prod"
  Normal  Created    7s    kubelet, ip-192-168-44-157.us-west-2.compute.internal  Created container envoy
  Normal  Started    7s    kubelet, ip-192-168-44-157.us-west-2.compute.internal  Started container envoy</programlisting>
                        <para>In the preceding output, you can see that the <code>proxyinit</code>
                            and <code>envoy</code> containers were added to the pod by the
                            controller. If you deployed the example service to Fargate, then the
                                <code>envoy</code> container was added to the pod by the controller,
                            but the <code>proxyinit</code> container was not.</para>
                    </step>
                </substeps>
            </step>
            <step>
                <para>(Optional) Install add-ons such as Prometheus, Grafana, &xraylong;, Jaeger,
                    and Datadog. For more information, see <ulink
                        url="https://github.com/aws/eks-charts#app-mesh-add-ons">&MESH;
                        add-ons</ulink> on GitHub. </para>
            </step>
        </procedure>
    </section>
    <section id="remove-integration">
        <info>
            <title id="remove-integration.title">Step 4: Clean up</title>
        </info>
        <para>Remove all of the example resources created in this tutorial. The controller also
            removes the resources that were created in the <code>my-mesh</code> &MESH; service
            mesh.</para>
        <programlisting><userinput>kubectl delete namespace <replaceable>my-apps</replaceable></userinput></programlisting>
        <para>If you created a Fargate profile for the example service, then remove it.</para>
        <programlisting><userinput>eksctl delete fargateprofile --name <replaceable>my-service-a</replaceable> --cluster <replaceable>my-cluster</replaceable> --region <replaceable>Region-code</replaceable></userinput></programlisting>
        <para>Delete the mesh.</para>
        <programlisting><userinput>kubectl delete mesh <replaceable>my-mesh</replaceable></userinput></programlisting>

        <para>(Optional) You can remove the Kubernetes integration components.</para>
        <programlisting><userinput>helm delete appmesh-controller -n appmesh-system</userinput></programlisting>
        <para>(Optional) If you deployed the Kubernetes integration components to Fargate, then
            delete the Fargate profile.</para>
        <programlisting><userinput>eksctl delete fargateprofile --name <replaceable>appmesh-system</replaceable> --cluster <replaceable>my-cluster</replaceable> --region <replaceable>Region-code</replaceable></userinput></programlisting>
    </section>
</section>
