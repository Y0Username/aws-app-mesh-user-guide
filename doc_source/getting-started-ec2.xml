<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "file://zonbook/docbookx.dtd"[
    <!ENTITY % xinclude SYSTEM "file://AWSShared/common/xinclude.mod">
    %xinclude;
    <!ENTITY % phrases-shared SYSTEM "file://AWSShared/common/phrases-shared.ent">
    %phrases-shared;
    <!ENTITY % phrases-appmesh SYSTEM "../shared/phrases-app-mesh.ent"> 
    %phrases-appmesh;
]>
<section role="topic" id="getting-started-ec2">
    <info>
        <title id="appmesh-getting-started-ec2.title">Getting started with &MESHlong; and
            &EC2;</title>
        <titleabbrev>&MESH; and &EC2;</titleabbrev>
    </info>

    <para>This topic helps you use &MESHlong; with an actual service that is running on &EC2;. This
        tutorial covers basic features of several &MESH; resource types.</para>
    <xi:include href="i-getting-started-scenario.xml"/>
    <section id="prerequisites">
        <info>
            <title id="prerequisites.title">Prerequisites</title>
        </info>
        <para>&MESH; supports Linux services that are registered with DNS, &CMAP;, or both. To use
            this getting started guide, we recommend that you have three existing services that are
            registered with DNS. You can create a service mesh and its resources even if the
            services don&apos;t exist, but you cannot use the mesh until you have deployed actual
            services.</para>
        <para>If you don&apos;t already have services running, you can launch
            &EC2; instances and deploy applications to them. For more information, see <ulink
                type="documentation" url="AWSEC2/latest/UserGuide/ec2-lamp-amazon-linux-2.html"
                >Tutorial: Getting started with Amazon EC2 Linux instances</ulink> in the
            &guide-ec2-user;. The remaining steps assume that the actual services are named
                <code>serviceA</code>, <code>serviceB</code>, and <code>serviceBv2</code> and that
            all services are discoverable through a namespace named <code>apps.local</code>. </para>
    </section>
    <xi:include href="i-getting-started-create-mesh-virtual-service.xml"/>
    <xi:include href="i-getting-started-create-virtual-node.xml"/>
    <xi:include href="i-getting-started-create-virtual-router-route.xml"/>
    <xi:include href="i-getting-started-review-create.xml"/>
    <xi:include href="i-getting-started-create-additional-resources.xml"/>
    <section id="update-services">
        <info>
            <title id="update-services.title">Step 6: Update services</title>
        </info>
        <para>After creating your mesh, you need to complete the following tasks:</para>
        <itemizedlist>
            <listitem>
                <para>Authorize the Envoy proxy that you deploy with each service to read the
                    configuration of one or more virtual nodes. For more information about how to
                    authorize the proxy, see <xref linkend="proxy-authorization" endterm="proxy-authorization.title"/>.</para>
            </listitem>
            <listitem>
                <para>To update your existing service, complete the steps that follow.</para>
            </listitem>
        </itemizedlist>

   
        <procedure>
            <title>To configure an &EC2; instance as a virtual node member</title>
            <step>
                <para>Create an &IAM; role.</para>
                <substeps>
                    <step>
                        <para>Create a file named <code>ec2-trust-relationship.json</code> with the
                            following contents.</para>
                        <programlisting language="json">{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}</programlisting>
                    </step>
                    <step>
                        <para>Create an &IAM; role with the following command.</para>
                        <programlisting><userinput>aws iam create-role --role-name <replaceable>mesh-virtual-node-service-b</replaceable> --assume-role-policy-document file://ec2-trust-relationship.json</userinput></programlisting>
                    </step>
                </substeps>
            </step>
            <step>
                <para>Attach &IAM; policies to the role that allow it to read from &ECR; and only
                    the configuration of a specific &MESH; virtual node.</para>
                <substeps>
                    <step>
                        <para>Create a file named <code>virtual-node-policy.json</code> with the
                            following contents. <code>apps</code> is the name of the mesh you
                            created in <xref linkend="create-mesh-and-virtual-service"/> and
                                <code>serviceB</code> is the name of the virtual node that you
                            created in <xref linkend="create-virtual-node"/>. Replace
                                <replaceable>&ExampleAWSAccountNo1;</replaceable> with your account
                            ID and <replaceable>us-west-2</replaceable> with the Region that you
                            created your mesh in.</para>
                        <programlisting language="json">{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "appmesh:StreamAggregatedResources",
            "Resource": [
                "arn:aws:appmesh:<replaceable>us-west-2</replaceable>:<replaceable>&ExampleAWSAccountNo1;</replaceable>:mesh/<replaceable>apps</replaceable>/virtualNode/<replaceable>serviceB</replaceable>"
            ]
        }
    ]
}</programlisting>
                    </step>
                    <step>
                        <para>Create the policy with the following command.</para>
                        <programlisting><userinput>aws iam create-policy --policy-name <replaceable>virtual-node-policy</replaceable> --policy-document file://virtual-node-policy.json</userinput></programlisting>
                    </step>
                    <step>
                        <para>Attach the policy that you created in the previous step to the role so
                            the role can read the configuration for only the <code>serviceB</code>
                            virtual node from &MESH;.</para>
                        <programlisting><userinput>aws iam attach-role-policy --policy-arn arn:aws:iam::<replaceable>&ExampleAWSAccountNo1;</replaceable>:policy/virtual-node-policy --role-name <code>mesh-virtual-node-service-b</code></userinput></programlisting>
                    </step>
                    <step>
                        <para>Attach the <code>AmazonEC2ContainerRegistryReadOnly</code> managed
                            policy to the role so that it can pull the Envoy container image from
                            &ECR;.</para>
                        <programlisting><userinput>aws iam attach-role-policy --policy-arn arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly --role-name <replaceable>mesh-virtual-node-service-b</replaceable></userinput></programlisting>
                    </step>
                </substeps>
            </step>
            <step>
                <para><ulink type="documentation"
                        url="AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#launch-instance-with-role"
                        >Launch an &EC2; instance with the &IAM; role</ulink> that you created.
                </para>
            </step>
            <step>
                <para>Connect to your instance via SSH.</para>
            </step>
            <step>
                <para>Install Docker and the &CLI; on your instance according to your operating
                    system documentation.</para>
            </step>
            <step>
                <para>Authenticate to the Envoy &ECR; repository in the Region that you want your
                    Docker client to pull the image from.</para>
                <itemizedlist>
                    <listitem>
                        <para>All Regions except &envoy-image-region-exceptions;. You can replace
                                <replaceable>&appmesh-default-region;</replaceable> with any <ulink
                                type="documentation" url="general/latest/gr/appmesh.html">supported
                                Region</ulink> except &envoy-image-region-exceptions;.</para>
                        <programlisting>$<userinput>aws ecr get-login-password \
    --region <replaceable>us-west-2</replaceable> \
| docker login \
    --username AWS \
    --password-stdin 840364872350.dkr.ecr.<replaceable>us-west-2</replaceable>.amazonaws.com</userinput></programlisting>
                    </listitem>
                    <listitem>
                        <para><code>me-south-1</code> Region</para>
                        <programlisting>$<userinput>aws ecr get-login-password \
    --region me-south-1 \
| docker login \
    --username AWS \
    --password-stdin 772975370895.dkr.ecr.me-south-1.amazonaws.com</userinput></programlisting>
                    </listitem>
                    <listitem>
                        <para><code>ap-east-1</code> Region</para>
                        <programlisting>$<userinput>aws ecr get-login-password \
    --region ap-east-1 \
| docker login \
    --username AWS \
    --password-stdin 856666278305.dkr.ecr.ap-east-1.amazonaws.com</userinput></programlisting>
                    </listitem>
                </itemizedlist>
                <!--  <substeps>
                <step><para>Retrieve the &ECR; repository account ID and latest version of the container image for your
                            Region, replacing <replaceable>region-code</replaceable> with a <ulink
                                type="documentation" url="general/latest/gr/appmesh.html">supported
                                &MESH; Region code</ulink>.</para>
                <programlisting><userinput>aws ssm get-parameter -name "/aws/service/appmesh/envoy" -region <replaceable>region-code</replaceable> -query "Parameter.Value" -output text</userinput></programlisting>
                <para>Output</para>
                <programlisting><replaceable>account-id</replaceable>.dkr.ecr.<replaceable>region-code</replaceable>.amazonaws.com/aws-appmesh-envoy:<replaceable>envoy-image-version</replaceable></programlisting></step>
                <step><para>Log into the appropriate &ECR; repository.</para><programlisting><userinput>aws ecr get-login-password \
    -region <replaceable>region-code</replaceable> \
| docker login \
    -username AWS \
    -password-stdin <replaceable>account-id</replaceable>.dkr.ecr.<replaceable>region-code</replaceable>.amazonaws.com</userinput></programlisting>
            </step>
            </substeps> -->
            </step>
            <step>
                <para>Run one of the following commands to start the &MESH; Envoy container on your
                    instance, depending on which Region you want to pull the image from. The
                        <replaceable>apps</replaceable> and <replaceable>serviceB</replaceable>
                    values are the mesh and virtual node names defined in the scenario. This
                    information tells the proxy which virtual node configuration to read from
                    &MESH;. To complete the scenario, you also need to complete these steps for the
                    &EC2; instances that host the services represented by the
                        <code>serviceBv2</code> and <code>serviceA</code> virtual nodes. For your
                    own application, replace these values with your own.</para>
                <itemizedlist>
                    <listitem>
                        <para>All Regions except &envoy-image-region-exceptions;. You can replace
                                <replaceable>Region-code</replaceable> with any <ulink
                                type="documentation" url="general/latest/gr/appmesh.html">supported
                                Region</ulink> except the &envoy-image-region-exceptions; Regions.
                            You can replace <code><replaceable>1337</replaceable></code> with any
                            value between <code>0</code> and <code>2147483647</code>.</para>
                        <programlisting><userinput>sudo docker run --detach --env APPMESH_RESOURCE_ARN=<code>mesh/<replaceable>apps</replaceable>/virtualNode/<replaceable>serviceB</replaceable></code>  \
-u <replaceable>1337</replaceable> --network host &envoy-image;</userinput></programlisting>
                    </listitem>
                    <listitem>
                        <para><code>me-south-1</code> Region. You can replace
                                    <code><replaceable>1337</replaceable></code> with any value
                            between <code>0</code> and <code>2147483647</code>.</para>
                        <programlisting><userinput>sudo docker run --detach --env APPMESH_RESOURCE_ARN=<code>mesh/<replaceable>apps</replaceable>/virtualNode/<replaceable>serviceB</replaceable></code>  \
-u <replaceable>1337</replaceable> --network host &envoy-image-me-south-1;</userinput></programlisting>
                    </listitem>
                    <listitem>
                        <para><code>ap-east-1</code> Region. You can replace
                                    <code><replaceable>1337</replaceable></code> with any value
                            between <code>0</code> and <code>2147483647</code>.</para>
                        <programlisting><userinput>sudo docker run --detach --env APPMESH_RESOURCE_ARN=<code>mesh/<replaceable>apps</replaceable>/virtualNode/<replaceable>serviceB</replaceable></code>  \
-u <replaceable>1337</replaceable> --network host &envoy-image-ap-east-1;</userinput></programlisting>
                    </listitem>
                </itemizedlist>
                <note><para>The <code>APPMESH_RESOURCE_ARN</code> property requires version <code>1.15.0</code> or later
                        of the Envoy image. For more information, see <xref linkend="envoy"
                        />.</para></note>
                &envoy-min-supported-version-note; 
            </step>
            <!--  <step>
                <para>Run the following command to start the &MESH; Envoy container on your instance. The <replaceable>apps</replaceable> and <replaceable>serviceB</replaceable> values are the mesh and virtual node
                    names defined in the scenario. This information tells the proxy which virtual node configuration to read from &MESH;. To complete the scenario, you also need to complete these steps for the &EC2; instances that host the services
                    represented by the <code>serviceBv2</code> and <code>serviceA</code> virtual nodes. For your own application, replace these values with your own. Replace <replaceable>envoy-image</replaceable> with the value returned in the
                    previous step. You can replace <code><replaceable>1337</replaceable></code> with any value between <code>0</code>&endash;<code>2147483647</code>.</para>
                        <programlisting><userinput>sudo docker run -detach -env APPMESH_RESOURCE_ARN=<code>mesh/<replaceable>apps</replaceable>/virtualNode/<replaceable>serviceB</replaceable></code>  \
-u <replaceable>1337</replaceable> -network host <replaceable>envoy-image</replaceable>;</userinput></programlisting>
            </step> -->
            <step minimized="true">
                <para>Select <code>Show more</code> below. Create a file named
                        <code>envoy-networking.sh</code> on your instance with the following
                    contents. Replace <replaceable>8000</replaceable> with the port that your
                    application code uses for incoming traffic. You can change the value for
                        <code>APPMESH_IGNORE_UID</code>, but the value must be the same as the value
                    that you specified in the previous step; for example <code>1337</code>. You can
                    add additional addresses to <code>APPMESH_EGRESS_IGNORED_IP</code> if necessary.
                    Do not modify any other lines.</para>
                <programlisting language="bash">#!/bin/bash -e

#
# Start of configurable options
#


#APPMESH_START_ENABLED="0"
APPMESH_IGNORE_UID="<replaceable>1337</replaceable>"
APPMESH_APP_PORTS="<replaceable>8000</replaceable>"
APPMESH_ENVOY_EGRESS_PORT="15001"
APPMESH_ENVOY_INGRESS_PORT="15000"
APPMESH_EGRESS_IGNORED_IP="169.254.169.254,169.254.170.2" 

# Enable routing on the application start.
[ -z "$APPMESH_START_ENABLED" ] &amp;&amp; APPMESH_START_ENABLED="0"

# Outbound traffic from the processess owned by the following UID/GID will be ignored.
if [ -z "$APPMESH_IGNORE_UID" ] &amp;&amp; [ -z "$APPMESH_IGNORE_GID" ]; then
    echo "Variables APPMESH_IGNORE_UID and/or APPMESH_IGNORE_GID must be set."
    echo "Envoy must run under those IDs to be able to properly route its outbound traffic."
    exit 1
fi

# Port numbers Application and Envoy are listening on.
if [ -z "$APPMESH_ENVOY_INGRESS_PORT" ] || [ -z "$APPMESH_ENVOY_EGRESS_PORT" ] || [ -z "$APPMESH_APP_PORTS" ]; then
    echo "All of APPMESH_ENVOY_INGRESS_PORT, APPMESH_ENVOY_EGRESS_PORT and APPMESH_APP_PORTS variables must be set."
    echo "If any one of them is not set we will not be able to route either inbound, outbound, or both directions."
    exit 1
fi

# Comma separated list of ports for which outbound traffic will be ignored, we always refuse to route SSH traffic.
if [ -z "$APPMESH_EGRESS_IGNORED_PORTS" ]; then
    APPMESH_EGRESS_IGNORED_PORTS="22"
else
    APPMESH_EGRESS_IGNORED_PORTS="$APPMESH_EGRESS_IGNORED_PORTS,22"
fi

#
# End of configurable options
#

APPMESH_LOCAL_ROUTE_TABLE_ID="100"
APPMESH_PACKET_MARK="0x1e7700ce"

function initialize() {
    echo "=== Initializing ==="
    iptables -t mangle -N APPMESH_INGRESS
    iptables -t nat -N APPMESH_INGRESS
    iptables -t nat -N APPMESH_EGRESS

    ip rule add fwmark "$APPMESH_PACKET_MARK" lookup $APPMESH_LOCAL_ROUTE_TABLE_ID
    ip route add local default dev lo table $APPMESH_LOCAL_ROUTE_TABLE_ID
}

function enable_egress_routing() {
    # Stuff to ignore
    [ ! -z "$APPMESH_IGNORE_UID" ] &amp;&amp; \
        iptables -t nat -A APPMESH_EGRESS \
        -m owner --uid-owner $APPMESH_IGNORE_UID \
        -j RETURN

    [ ! -z "$APPMESH_IGNORE_GID" ] &amp;&amp; \
        iptables -t nat -A APPMESH_EGRESS \
        -m owner --gid-owner $APPMESH_IGNORE_GID \
        -j RETURN

    [ ! -z "$APPMESH_EGRESS_IGNORED_PORTS" ] &amp;&amp; \
        iptables -t nat -A APPMESH_EGRESS \
        -p tcp \
        -m multiport --dports "$APPMESH_EGRESS_IGNORED_PORTS" \
        -j RETURN

    [ ! -z "$APPMESH_EGRESS_IGNORED_IP" ] &amp;&amp; \
        iptables -t nat -A APPMESH_EGRESS \
        -p tcp \
        -d "$APPMESH_EGRESS_IGNORED_IP" \
        -j RETURN

    # Redirect everything that is not ignored
    iptables -t nat -A APPMESH_EGRESS \
        -p tcp \
        -j REDIRECT --to $APPMESH_ENVOY_EGRESS_PORT

    # Apply APPMESH_EGRESS chain to non local traffic
    iptables -t nat -A OUTPUT \
        -p tcp \
        -m addrtype ! --dst-type LOCAL \
        -j APPMESH_EGRESS
}

function enable_ingress_redirect_routing() {
    # Route everything arriving at the application port to Envoy
    iptables -t nat -A APPMESH_INGRESS \
        -p tcp \
        -m multiport --dports "$APPMESH_APP_PORTS" \
        -j REDIRECT --to-port "$APPMESH_ENVOY_INGRESS_PORT"

    # Apply AppMesh inbound chain to everything non-local
    iptables -t nat -A PREROUTING \
        -p tcp \
        -m addrtype ! --src-type LOCAL \
        -j APPMESH_INGRESS
}

function enable_routing() {
    echo "=== Enabling routing ==="
    enable_egress_routing
    enable_ingress_redirect_routing
}

function disable_routing() {
    echo "=== Disabling routing ==="
    iptables -F
    iptables -F -t nat
    iptables -F -t mangle
}

function dump_status() {
    echo "=== Routing rules ==="
    ip rule
    echo "=== AppMesh routing table ==="
    ip route list table $APPMESH_LOCAL_ROUTE_TABLE_ID
    echo "=== iptables FORWARD table ==="
    iptables -L -v -n
    echo "=== iptables NAT table ==="
    iptables -t nat -L -v -n
    echo "=== iptables MANGLE table ==="
    iptables -t mangle -L -v -n
}

function main_loop() {
    echo "=== Entering main loop ==="
    while read -p &apos;&gt; &apos; cmd; do
        case "$cmd" in
            "quit")
                break
                ;;
            "status")
                dump_status
                ;;
            "enable")
                enable_routing
                ;;
            "disable")
                disable_routing
                ;;
            *)
                echo "Available commands: quit, status, enable, disable"
                ;;
        esac
    done
}

function print_config() {
    echo "=== Input configuration ==="
    env | grep APPMESH_ || true
}

print_config

initialize

if [ "$APPMESH_START_ENABLED" == "1" ]; then
    enable_routing
fi

main_loop</programlisting>
            </step>
            <step>
                <para>To configure <code>iptables</code> rules to route application traffic to the
                    Envoy proxy, run the script that you created in the previous step.</para>
                <programlisting><userinput>sudo ./envoy-networking.sh</userinput></programlisting>
            </step>
            <step>
                <para>Start your virtual node application code.</para>
            </step>
        </procedure>
    </section>
</section>
