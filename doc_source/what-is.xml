<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "file://zonbook/docbookx.dtd"
[
    <!ENTITY % xinclude SYSTEM "file://AWSShared/common/xinclude.mod">
    %xinclude;
    <!ENTITY % phrases-shared SYSTEM "file://AWSShared/common/phrases-shared.ent">
    %phrases-shared;
    <!ENTITY % phrases-appmesh SYSTEM "../shared/phrases-app-mesh.ent"> 
    %phrases-appmesh;  
]>
<chapter role="topic" id="what-is-app-mesh">
 <info>
  <title id="what-is-app-mesh.title">What Is &MESHlong;?</title>
  <abstract>
   <para>Learn about &MESHlong;.</para>
  </abstract>
 </info>
 <para>&MESHlong; is a service mesh that makes it easy to monitor and control services. A service
  mesh is an infrastructure layer dedicated to handling service-to-service communication, usually
  through an array of lightweight network proxies deployed alongside the application code. &MESH;
  standardizes how your services communicate, giving you end-to-end visibility and helping to ensure
  high availability for your applications. &MESH; gives you consistent visibility and network
  traffic controls for every service in an application. </para>
 <para/>
 <section id="example-application">
  <info>
   <title id="example-application.title">Adding &MESH; to an example application</title>
  </info>
  <para>Consider the following simple example application, that doesn’t use &MESH;. The two services
   can be running on &FARGATElong;, &ECSfirst;, &EKSlong; (&EKS;), Kubernetes on &EC2long; (&EC2;)
   instances, or on &EC2; instances with Docker.</para>
  <mediaobject>
   <imageobject>
    <imagedata fileref="images/simple-app-diagram.png" format="PNG" width="100%" scalefit="1"
     contentdepth="100%"/>
   </imageobject>
  </mediaobject>
  <para>In this illustration, both <code>serviceA</code> and <code>serviceB</code> are discoverable
   through the <code>apps.local</code> namespace. Let's say, for example, you decide to deploy a new
   version of <code>serviceb.apps.local</code> named <code>servicebv2.apps.local</code>. Next, you
   want to direct a percentage of the traffic from <code>servicea.apps.local</code> to
    <code>serviceb.apps.local</code> and a percentage to <code>servicebv2.apps.local</code>. When
   you're sure that <code>servicebv2</code> is performing well, you want to send 100 percent of the
   traffic to it.</para>
  <para> &MESH; can help you do this without changing any application code or registered service
   names. If you use &MESH; with this example application, then your mesh might look like the
   following illustration. </para>
  <mediaobject>
   <imageobject>
    <imagedata fileref="images/simple-app-with-mesh-diagram.png" format="PNG" width="100%"
     scalefit="1" contentdepth="100%"/>
   </imageobject>
  </mediaobject>
  <para>In this configuration, the services no longer communicate with each other directly. Instead,
   they communicate with each other through a proxy. The proxy deployed with the
    <code>servicea.apps.local</code> service reads the &MESH; configuration and sends traffic to
    <code>serviceb.apps.local</code> or <code>servicebv2.apps.local</code>, based on the
   configuration.</para>
 </section>
 <section id="app_mesh_components">
  <info>
   <title id="app_mesh_components.title">Components of &MESH;</title>
  </info>
  <para>&MESH; is made up of the following components, illustrated in the previous example:</para>
  <itemizedlist>
   <listitem>
    <para><emphasis role="bold">Service mesh</emphasis> &endash; A service mesh is a logical
     boundary for network traffic between the services that reside within it. In the example, the
     mesh is named <code>apps</code>, and it contains all other resources for the mesh. For more
     information, see <xref linkend="meshes" endterm="meshes.title"/>.</para>
   </listitem>
   <listitem>
    <para><emphasis role="bold">Virtual services</emphasis> &endash; A virtual service is an
     abstraction of an actual service that is provided by a virtual node, directly or indirectly, by
     means of a virtual router. In the illustration, two virtual services represent the two actual
     services. The names of the virtual services are the discoverable names of the actual services.
     When a virtual service and an actual service have the same name, multiple services can
     communicate with each other using the same names that they used before &MESH; was implemented.
     For more information, see <xref linkend="virtual_services" endterm="virtual_services.title"
     />.</para>
   </listitem>
   <listitem>
    <para><emphasis role="bold">Virtual nodes</emphasis> &endash; A virtual node acts as a logical
     pointer to a discoverable service, such as an &ECS; or Kubernetes service. For each virtual
     service, you will have at least one virtual node. In the illustration, the
      <code>servicea.apps.local</code> virtual service gets configuration information for the
     virtual node named <code>serviceA</code>. The <code>serviceA</code> virtual node is configured
     with the <code>servicea.apps.local</code> name for service discovery. The
      <code>serviceb.apps.local</code> virtual service is configured to route traffic to the
      <code>serviceB</code> and <code>serviceBv2</code> virtual nodes through a virtual router named
      <code>serviceB</code>. For more information, see <xref linkend="virtual_nodes"
      endterm="virtual_nodes.title"/>.</para>
   </listitem>
   <listitem>
    <para><emphasis role="bold">Virtual routers and routes</emphasis> &endash; Virtual routers
     handle traffic for one or more virtual services within your mesh. A route is associated to a
     virtual router. The route is used to match requests for the virtual router and to distribute
     traffic to its associated virtual nodes. In the previous illustration, the
      <code>serviceB</code> virtual router has a route that directs a percentage of traffic to the
      <code>serviceB</code> virtual node, and a percentage of traffic to the <code>serviceBv2</code>
     virtual node. You can set the percentage of traffic routed to a particular virtual node and
     change it over time. You can route traffic based on criteria such as HTTP headers, URL paths,
     or gRPC service and method names. You can configure retry policies to retry a connection if
     there is an error in the response. For example, in the illustration, the retry policy for the
     route can specify that a connection to <code>serviceb.apps.local</code> is retried five times,
     with ten seconds between retry attempts, if <code>serviceb.apps.local</code> returns specific
     types of errors. For more information, see <xref linkend="virtual_routers"
      endterm="virtual_routers.title"/> and <xref linkend="routes" endterm="routes.title"/>.</para>
   </listitem>
   <listitem>
    <para><emphasis role="bold">Proxy</emphasis> &endash; You configure your services to use the
     proxy after you create your mesh and its resources. The proxy reads the &MESH; configuration
     and directs traffic appropriately. In the illustration, all communication from
      <code>servicea.apps.local</code> to <code>serviceb.apps.local</code> goes through the proxy
     deployed with each service. The services communicate with each other using the same service
     discovery names that they used before introducing &MESH;. Because the proxy reads the &MESH;
     configuration, you can control how the two services communicate with each other. When you want
     change the &MESH; configuration, you don’t need to change or redeploy the services themselves
     or the proxies. For more information, see <link linkend="envoy" endterm="envoy.title"/>.</para>
   </listitem>
  </itemizedlist>
 </section>
 <section id="how_to_get_started">
  <info>
   <title id="how_to_get_started.title">How to get started</title>
  </info>
  <para>To use &MESH; you must have an existing service running on &FARGATElong;, &ECS;, &EKS;,
   Kubernetes on &EC2;, or &EC2; with Docker.</para>
  <para>To get started with &MESH;, see one of the following guides:</para>
  <itemizedlist>
   <listitem>
    <para><ulink type="documentation" url="app-mesh/latest/userguide/getting-started-ecs.html"
      >Getting Started with &MESH; and &ECS;</ulink></para>
   </listitem>
   <listitem>
    <para><ulink type="documentation" url="eks/latest/userguide/appmesh-getting-started.html"
      >Getting Started with &MESH; and Kubernetes</ulink></para>
   </listitem>
   <listitem>
    <para><ulink type="documentation" url="app-mesh/latest/userguide/getting-started-ec2.html"
      >Getting Started with &MESH; and &EC2;</ulink></para>
   </listitem>
  </itemizedlist>
 </section>
 <section id="accessing_app_mesh">
  <info>
   <title id="accessing_app_mesh.title">Accessing &MESH;</title>
  </info>
  <para>You can work with &MESH; in the following ways:</para>
  <variablelist role="termdef">
   <varlistentry>
    <term>&console;</term>
    <listitem>
     <para>The console is a browser-based interface that you can use to manage &MESH; resources. You
      can open the &MESH; console at <ulink type="console" url="appmesh"
       >&url-console-domain;appmesh/</ulink>.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&CLI;</term>
    <listitem>
     <para>Provides commands for a broad set of &AWS; products, and is supported on Windows, Mac,
      and Linux. To get started, see &link-cli-ug;. For more information about the commands for
      &MESH;, see <ulink type="documentation" url="cli/latest/reference/appmesh/index.html#"
       >appmesh</ulink> in the <ulink type="documentation" url="cli/latest/reference/"
       >&guide-cli-ref;</ulink>.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&TWPlong;</term>
    <listitem>
     <para>Provides commands for a broad set of &AWS; products for those who script in the
      PowerShell environment. To get started, see the <ulink type="documentation"
       url="powershell/latest/userguide/pstools-welcome.html">&guide-twp-ug;</ulink>. For more
      information about the cmdlets for &MESH;, see <ulink type="documentation"
       url="powershell/latest/reference/items/AppMesh_cmdlets.html">&MESH;</ulink> in the <ulink
       type="documentation" url="powershell/latest/reference/index.html">&AWS; Tools for PowerShell
       Cmdlet Reference</ulink>.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&CFNlong;</term>
    <listitem>
     <para>Enables you to create a template that describes all of the &AWS; resources that you want.
      Using the template, &CFN; provisions and configures the resources for you. To get started, see
      &link-cfn-user;. For more information about the &MESH; resource types, see <ulink
       type="documentation" url="AWSCloudFormation/latest/UserGuide/AWS_AppMesh.html">&MESH;
       Resource Type Reference</ulink> in the <ulink type="documentation"
       url="AWSCloudFormation/latest/UserGuide/template-reference.html">&CFNlong; Template
       Reference</ulink>.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&AWS; SDKs</term>
    <listitem>&use-sdks-now; <para>For more information about the &MESH; APIs, see the <ulink
       type="documentation" url="app-mesh/latest/APIReference/Welcome.html"
      >&guide-mesh-api;</ulink>.</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </section>
</chapter>
